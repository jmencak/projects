#!/usr/bin/perl

# Author: Jiri Mencak
#
# usage: haproxy-ocp-postprocess <dir>  dir = directory where router-*.csv files can be found
#
# The purpose of this script is to
# -output the chart data in JSON format
# -output html files (router-*.html) with embedded javascript, using d3.js libraries
#
# The input file that this scripts processes must be in the format which is generated by haproxy

use strict;
use warnings;

# Check for an alternate tools library path for testing
my $_test_alt_tools_lib;
BEGIN {
        my $_pbench_tspp_dir = $ENV{'pbench_tspp_dir'};
        $_test_alt_tools_lib=$ENV{_TEST_ALTERNATE_TOOLS_LIBRARY};
        if (not defined $_test_alt_tools_lib or not -d $_test_alt_tools_lib) {
                $_test_alt_tools_lib = "$_pbench_tspp_dir";
        }
}
use lib "$_test_alt_tools_lib";
no lib ".";
use GenData qw(gen_data);
use File::Find;

my $dir=$ARGV[0];
my %haproxy;
my $timestamp;
my $timestamp_ms;
my @router_csv;
my $index_page='index.html';

# http://cbonte.github.io/haproxy-dconv/1.5/configuration.html#9.1
my @haproxy_show=(
#  "pxname", # proxy name,
#  "svname", # service name, # FRONTEND for frontend, BACKEND for backend, any name for server/listener)
  "qcur", # current queued requests, # For the backend this reports the number queued without a server assigned.
  "qmax", # max value of qcur,
  "scur", # current sessions,
  "smax", # max sessions,
  "slim", # configured session limit,
  "stot", # cumulative number of connections,
  "bin", # bytes in,
  "bout", # bytes out,
  "dreq", # requests denied because of security concerns,
  "dresp", # responses denied because of security concerns,
  "ereq", # request errors,
  "econ", # number of requests that encountered an error trying to connect to a backend server,
  "eresp", # response errors including srv_abrt,
  "wretr", # number of times a connection to a server was retried,
  "wredis", # number of times a request was redispatched to another,
#  "status", # status (UP/DOWN/NOLB/MAINT/MAINT(via)...),
  "weight", # total weight (backend), server weight (server),
  "act", # number of active servers (backend), server is active (server),
  "bck", # number of backup servers (backend), server is backup (server),
  "chkfail", # number of failed checks, # Only counts checks failed when the server is up.
  "chkdown", # number of UP->DOWN transitions,
  "lastchg", # number of seconds since the last UP<->DOWN transition,
  "downtime", # total downtime (in seconds),
  "qlimit", # configured maxqueue for the server, # or nothing in the value is 0 (default, meaning no limit)
  "pid", # process id (0 for first instance, 1 for second, ...),
  "iid", # unique proxy id, 
  "sid", # server id (unique inside a proxy),
  "throttle", # current throttle percentage for the server,
  "lbtot", # total number of times a server was selected,
  "tracked", # id of proxy/server if tracking is enabled, 
  "type", # (0=frontend, 1=backend, 2=server, 3=socket/listener),
  "rate", # number of sessions per second over last elapsed second,
  "rate_lim", # configured limit on new sessions per second,
  "rate_max", # max number of new sessions per second,
#  "check_status", # status of last health check
  "check_code", # layer5-7 code, if available,
  "check_duration", # time in ms took to finish last health check,
  "hrsp_1xx", # http responses with 1xx code,
  "hrsp_2xx", # http responses with 2xx code,
  "hrsp_3xx", # http responses with 3xx code,
  "hrsp_4xx", # http responses with 4xx code,
  "hrsp_5xx", # http responses with 5xx code,
  "hrsp_other", # http responses with other codes (protocol error),
  "hanafail", # failed health checks details,
  "req_rate", # HTTP requests per second over last elapsed second,
  "req_rate_max", # max number of HTTP requests per second observed,
  "req_tot", # total number of HTTP requests received,
  "cli_abrt", # number of data transfers aborted by the client,
  "srv_abrt", # number of data transfers aborted by the server,
  "comp_in", # number of HTTP response bytes fed to the compressor,
  "comp_out", # number of HTTP response bytes emitted by the compressor,
  "comp_byp", # number of bytes that bypassed the HTTP compressor,
  "comp_rsp", # number of HTTP responses that were compressed,
  "lastsess", # number of seconds since last session assigned to server/backend,
#  "last_chk", # last health check contents or textual error,
#  "last_agt", # last agent check contents or textual error
  "qtime", # the average queue time in ms over the 1024 last requests,
  "ctime", # the average connect time in ms over the 1024 last requests,
  "rtime", # the average response time in ms over the 1024 last requests, # 0 for TCP
  "ttime", # the average total session time in ms over the 1024 last,
);

my %haproxy_col2name=(
  'pxname' => 'proxy name',
  'svname' => 'service name', # FRONTEND for frontend, BACKEND for backend, any name for server/listener)
  'qcur' => 'current queued requests', # For the backend this reports the number queued without a server assigned.
  'qmax' => 'max value of qcur',
  'scur' => 'current sessions',
  'smax' => 'max sessions',
  'slim' => 'configured session limit',
  'stot' => 'cumulative number of connections',
  'bin' => 'bytes in',
  'bout' => 'bytes out',
  'dreq' => 'requests denied because of security concerns',
  'dresp' => 'responses denied because of security concerns',
  'ereq' => 'request errors',
  'econ' => 'number of requests that encountered an error trying to connect to a backend server',
  'eresp' => 'response errors including srv_abrt',
  'wretr' => 'number of times a connection to a server was retried',
  'wredis' => 'number of times a request was redispatched to another',
  'status' => 'status (UP/DOWN/NOLB/MAINT/MAINT(via)...)',
  'weight' => 'total weight (backend), server weight (server)',
  'act' => 'number of active servers (backend), server is active (server)',
  'bck' => 'number of backup servers (backend), server is backup (server)',
  'chkfail' => 'number of failed checks', # Only counts checks failed when the server is up.
  'chkdown' => 'number of UP->DOWN transitions',
  'lastchg' => 'number of seconds since the last UP<->DOWN transition',
  'downtime' => 'total downtime (in seconds)',
  'qlimit' => 'configured maxqueue for the server', # or nothing in the value is 0 (default, meaning no limit)
  'pid' => 'process id (0 for first instance, 1 for second, ...)',
  'iid' => 'unique proxy id', 
  'sid' => 'server id (unique inside a proxy)',
  'throttle' => 'current throttle percentage for the server',
  'lbtot' => 'total number of times a server was selected',
  'tracked' => 'id of proxy/server if tracking is enabled', 
  'type' => '(0:frontend, 1:backend, 2:server, 3:socket/listener)',
  'rate' => 'number of sessions per second over last elapsed second',
  'rate_lim' => 'configured limit on new sessions per second',
  'rate_max' => 'max number of new sessions per second',
  'check_status' => 'status of last health check',
  'check_code' => 'layer5-7 code, if available',
  'check_duration' => 'time in ms took to finish last health check',
   'hrsp_1xx' => 'http responses with 1xx code',
   'hrsp_2xx' => 'http responses with 2xx code',
   'hrsp_3xx' => 'http responses with 3xx code',
   'hrsp_4xx' => 'http responses with 4xx code',
   'hrsp_5xx' => 'http responses with 5xx code',
   'hrsp_other' => 'http responses with other codes (protocol error)',
   'hanafail' => 'failed health checks details',
   'req_rate' => 'HTTP requests per second over last elapsed second',
   'req_rate_max' => 'max number of HTTP requests per second observed',
   'req_tot' => 'total number of HTTP requests received',
   'cli_abrt' => 'number of data transfers aborted by the client',
   'srv_abrt' => 'number of data transfers aborted by the server',
   'comp_in' => 'number of HTTP response bytes fed to the compressor',
   'comp_out' => 'number of HTTP response bytes emitted by the compressor',
   'comp_byp' => 'number of bytes that bypassed the HTTP compressor',
   'comp_rsp' => 'number of HTTP responses that were compressed',
   'lastsess' => 'number of seconds since last session assigned to server/backend',
   'last_chk' => 'last health check contents or textual error',
   'last_agt' => 'last agent check contents or textual error',
   'qtime' => 'the average queue time in ms over the 1024 last requests',
   'ctime' => 'the average connect time in ms over the 1024 last requests',
   'rtime' => 'the average response time in ms over the 1024 last requests', # (0 for TCP
   'ttime' => 'the average total session time in ms over the 1024 last',
);

sub html_head {
    my $fh = shift;
    my $title = "index"; $title = shift if @_;
  
    print $fh <<"_HTML_HEAD_";
<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
    <title>$title</title>
  </head>
  <body>
_HTML_HEAD_
}

sub html_tail {
    my $fh = shift;

    print $fh <<'_HTML_TAIL_';
  </body>
</html>
_HTML_TAIL_
}

sub html_router_index {
    my $fh = shift;
    my $router_name = shift;

    my $graph_name;
    foreach my $key (@haproxy_show) {
        html_ln($fh, "${router_name}-${key}.html", graph_name($key));
        print $fh "<br>\n";
    }
}

sub html_ln {
    my $fh = shift;
    my $href = 'index.html'; $href = shift if @_;
    my $title = 'title'; $title = shift if @_;

    print $fh "    <a href=\"$href\">$title</a>";
}

sub e2z {
   my $v = shift;

   return 0 if !defined $v or $v eq "";
   return $v;
}

sub graph_name {
  my $key = shift;
  my $graph_name;
   
  $graph_name="$key: $haproxy_col2name{$key}";
  $graph_name=~tr/\//-/;  # used as filename -> issues with '/' being interpreted as path separator!
  return $graph_name;
}

find(sub { push @router_csv, $File::Find::name if /router-.*\.csv$/ }, ("$dir"));
open(my $index_page_fh, ">$index_page") || die "could not open `$index_page' for writing\n";
html_head($index_page_fh);
foreach my $csv (@router_csv) {
    my $router_index = $csv; $router_index =~ s/\.csv$/.html/;
    my $router_name = $csv; $router_name =~ s/^.*\/([^\/]*)\.csv$/$1/;
    open(ROUTER_CSV, "$csv") || die "could not find `$csv'\n"; 
    open(my $router_index_fh, ">$router_index") || die "could not open `$router_index' for writing\n";
    html_ln($index_page_fh, "${router_name}.html", $router_name);
    html_ln($index_page_fh, "logs", "logs");
    print $index_page_fh "<br>\n";
    html_head($router_index_fh, $router_name);
    html_router_index($router_index_fh, $router_name);
    while (my $line = <ROUTER_CSV>) {
        chomp $line;

        next if ($line =~ /^\s*#/);	# ignore comments and HAProxy stats headers

        # timestamp: 1404854661.042987923
        if ($line =~ /^timestamp:\s(\d+\.\d+)/) {
            $timestamp = $1;
            $timestamp_ms = 1000 * $timestamp;
            next;
        }

        if ($line =~ /^\S+,/ ) {
            my ($pxname,$svname,$qcur,$qmax,$scur,$smax,$slim,$stot,
                $bin,$bout,$dreq,$dresp,$ereq,$econ,$eresp,$wretr,$wredis,
                $status,$weight,$act,$bck,$chkfail,$chkdown,$lastchg,$downtime,
                $qlimit,$pid,$iid,$sid,$throttle,$lbtot,$tracked,$type,$rate,
                $rate_lim,$rate_max,$check_status,$check_code,$check_duration,
                $hrsp_1xx,$hrsp_2xx,$hrsp_3xx,$hrsp_4xx,$hrsp_5xx,$hrsp_other,
                $hanafail,$req_rate,$req_rate_max,$req_tot,$cli_abrt,$srv_abrt,$comp_in,
                $comp_out,$comp_byp,$comp_rsp,$lastsess,$last_chk,$last_agt,$qtime,
                $ctime,$rtime,$ttime,) = split /,/, $line;

            my ($val, $graph_name);
            foreach my $key (@haproxy_show) {
                $val=eval('"$' . $key . '"');
                $graph_name=graph_name($key);
                $haproxy{"$router_name-$key"}{"$graph_name"}{"${pxname}_${svname}"}{$timestamp_ms} = e2z($val);
            }
        }
    }
    html_tail($router_index_fh);
    close($router_index_fh);
    close(ROUTER_CSV);
}
html_tail($index_page_fh);
close($index_page_fh);

my %graph_threshold;
my %graph_type;
gen_data(\%haproxy, \%graph_type, \%graph_threshold, $dir); 
