#!/bin/bash

script_path=`dirname $0`
script_name=`basename $0`
pbench_bin="`cd ${script_path}/..; /bin/pwd`"

# source the base script
. "$pbench_bin"/base

# Perftool scripts must provide the following functions
# 1) Install the tool
# 2) Start data collection
# 3) Stop data collection
# 4) post-process the data

# Defaults
tool=$script_name
group=default
dir=""
mode=""
interval="10"
iteration="1"
options="none"
origin_master="/etc/sysconfig/origin-master"
ose_openshift_master="/etc/sysconfig/atomic-openshift-master"

# Functions
usage() {
    local err=$1

    cat <<_USAGE_ 1>&2
$script_name: you specified an invalid option

The following options are available:

    --install                   install this perf tool
    --start|stop|postprocess    start/stop/postprocess the data collection
    --postproceess-script       run this user-provided script when postprocessing this tool
    --collect                   collect mode, get the actual HAProxy statistics
    --iteration=int             the iteration (required)
    --group=str                 the perftool group (required)
    --dir=str                   directory to store data collection (required)
    --interval=int              number of seconds between each data collection
_USAGE_

    test "$err" && exit $err
}

haproxy_data_collect() {
    local router_namespace=default

    while true ; do
        for router in $(oc get pod --no-headers -n ${router_namespace} | awk '/^router-/ {print $1}') ; do
            cmd="echo 'show stat' | socat - UNIX-CONNECT:/var/lib/haproxy/run/haproxy.sock"
 
            date '+# %Y-%d-%m %H:%M:%S' >> $tool_output_dir/${router}.csv
            oc exec "${router}" -n ${router_namespace} -- /bin/sh -c "$cmd" >> $tool_output_dir/${router}.csv &
            sleep $interval
        done
     done
}

# Process options and arguments
opts=$(getopt -q -o idp --longoptions "dir:,group:,iteration:,interval:,start,stop,install,postprocess,collect,postprocess-script:" -n "getopt.sh" -- "$@")

if [ $? -ne 0 ]; then
    usage 1
fi

eval set -- "$opts"
unset opts
while true; do
    case "$1" in
    --install)
        mode="install"
        shift
    ;;
    --start)
        mode="start"
        shift
    ;;
    --stop)
        mode="stop"
        shift
    ;;
    --postprocess)
        mode="postprocess"
        shift
    ;;
    --collect)
        mode="collect"
        shift
    ;;
    -d|--dir)
        shift
        if [ -n "$1" ]; then
            dir="$1"
            shift
        fi
    ;;
    -g|--group)
        shift
        if [ -n "$1" ]; then
            group="$1"
            shift
        fi
    ;;
    -i|--iteration)
        shift
        if [ -n "$1" ]; then
            iteration="$1"
            shift
        fi
    ;;
    --interval)
        shift
        if [ -n "$1" ]; then
            interval="$1"
            shift
        fi
    ;;
    --postprocess-script)
        shift
        if [ -n "$1" ]; then
            postprocess_script="$1"
            shift
        fi
    ;;
    --)
        shift
        break
    ;;
    *)
        usage 1
    ;;
    esac
done

tool_dir="$dir/tools-$group"
tool_output_dir=$tool_dir/$tool     # all tools keep data in their tool specific dir
tool_cmd_file="$tool_output_dir/$tool.cmd"
tool_pid_file=$pbench_tmp/$group.$iteration.$tool.pid
tool_stdout_file=$tool_output_dir/$tool-stdout.txt
tool_stderr_file=$tool_output_dir/$tool-stderr.txt

case "$mode" in
    install)
        if [[ -e $ose_openshift_master || -e $origin_master ]]; then
            check_install_rpm $tool_package
        else
            printf "This machine is not Openshift master, it is not possible to start $tool on this machine\n"
            exit 1
        fi
    ;;
    start)
        mkdir -p $tool_output_dir
        pushd $tool_output_dir >/dev/null
        echo "${BASH_SOURCE} --dir=${dir} --interval=${interval} --collect" >$tool_cmd_file
        chmod +x $tool_cmd_file
        debug_log "$script_name: running $tool_cmd"
        $tool_cmd_file >"$tool_stdout_file" 2>"$tool_stderr_file" & echo $! >$tool_pid_file
        popd >/dev/null
        wait
    ;;
    stop)
        pid=`cat $tool_pid_file`
        debug_log "stopping $script_name"
        kill $pid && /bin/rm -f $tool_pid_file
    ;;
    postprocess)
        debug_log "postprocessing $script_name"
        pushd $tool_output_dir >/dev/null
        if [ -e "$postprocess_script" ]; then
            chmod +x $postprocess_script
            $postprocess_script 2>&1 >postprocess-output.txt
        fi
        popd >/dev/null
    ;;
    collect)
        pushd $tool_output_dir >/dev/null
        debug_log "collecting $script_name stats"
        haproxy_data_collect
        popd >/dev/null
    ;;
esac
